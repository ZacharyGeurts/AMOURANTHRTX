#version 460
#extension GL_EXT_shader_image_load_formatted : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_EXT_shader_atomic_float : enable  // For reductions if needed

// Layout: Matches stats descriptor set (binding 0=prevOutput, 1=stats out)
layout(set = 0, binding = 0, rgba32f) readonly uniform image2D prevOutput;
layout(set = 0, binding = 1, std430) writeonly buffer StatsOut {
    uint   hitCount;
    uint   totalRays;  // Fixed to image pixels for proxy
    float  variance;
    float  entropy;
    float  gradMag;
    float  pad[3];
} stats;

// Shared memory for tile reduction (16x16 workgroup)
shared float sharedLuma[16][16];
shared float sharedSqDiff[16][16];  // For variance
shared uint  sharedHist[4];         // Simple 4-bin histogram for entropy
shared float sharedGrad[16][16];    // For gradient mag

// Simple luma (grayscale approx)
float luma(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

// Sobel kernel for grad (central pixel)
float sobelGrad(ivec2 pos) {
    const float hx[3] = {-1, 0, 1};
    const float hy[3] = {-1, -2, -1};
    float gx = 0.0, gy = 0.0;
    for (int y = -1; y <= 1; ++y) {
        for (int x = -1; x <= 1; ++x) {
            vec4 px = imageLoad(prevOutput, pos + ivec2(x, y));
            float lum = luma(px.rgb);
            gx += lum * hx[x + 1];
            gy += lum * hy[y + 1];
        }
    }
    return sqrt(gx * gx + gy * gy) / 8.0;  // Normalize
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 tileID = ivec2(gl_WorkGroupID.xy);
    const uint tileSize = 16u;

    // Clamp to image bounds
    if (pos.x >= imageSize(prevOutput).x || pos.y >= imageSize(prevOutput).y) return;

    // Load pixel
    vec4 px = imageLoad(prevOutput, pos);
    float lum = luma(px.rgb);
    bool isHit = any(greaterThan(px.rgb, vec3(0.01)));  // Proxy: non-black = hit

    // 1. Hit count (atomic increment if hit)
    if (isHit) {
        atomicAdd(stats.hitCount, 1u);
    }

    // Tile-local reductions
    uint localIdx = gl_LocalInvocationID.y * tileSize + gl_LocalInvocationID.x;
    barrier();  // Sync workgroup

    // Store to shared for variance/grad
    if (localIdx < tileSize * tileSize) {
        sharedLuma[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = lum;
        sharedSqDiff[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = (lum - 0.5) * (lum - 0.5);  // Assume mean~0.5 init
        sharedGrad[gl_LocalInvocationID.y][gl_LocalInvocationID.x] = sobelGrad(pos);
    }
    barrier();

    // Reduce variance in shared (simple mean + var)
    float sumLum = 0.0, sumSq = 0.0;
    for (uint i = 0u; i < tileSize; ++i) {
        sumLum += sharedLuma[gl_LocalInvocationID.y][i];
        sumSq += sharedSqDiff[gl_LocalInvocationID.y][i];
    }
    float tileMean = sumLum / float(tileSize);
    float tileVar = sumSq / float(tileSize) - tileMean * tileMean;
    barrier();

    // WG reduce: average vars
    if (gl_LocalInvocationID.x == 0u) {
        sharedLuma[gl_LocalInvocationID.y][0] = tileVar;  // Reuse shared
    }
    barrier();
    float wgVar = 0.0;
    for (uint i = 0u; i < tileSize; ++i) {
        wgVar += sharedLuma[i][0];
    }
    wgVar /= float(tileSize);

    // Entropy: simple 4-bin hist (0-0.25,0.25-0.5,etc.)
    uint bin = uint(lum * 4.0);
    atomicAdd(sharedHist[bin], 1u);
    barrier();
    if (gl_LocalInvocationID.x == 0u && gl_LocalInvocationID.y == 0u) {
        float ent = 0.0;
        float total = float(tileSize * tileSize);
        for (uint b = 0u; b < 4u; ++b) {
            float p = float(sharedHist[b]) / total;
            if (p > 0.0) ent -= p * log2(p);
        }
        sharedLuma[0][0] = ent;  // Temp store
    }
    barrier();
    float wgEnt = sharedLuma[0][0];  // Broadcast

    // Grad mag: max in tile
    float tileMaxGrad = 0.0;
    for (uint i = 0u; i < tileSize; ++i) {
        tileMaxGrad = max(tileMaxGrad, sharedGrad[gl_LocalInvocationID.y][i]);
    }
    barrier();
    if (gl_LocalInvocationID.x == 0u) {
        sharedGrad[gl_LocalInvocationID.y][0] = tileMaxGrad;
    }
    barrier();
    float wgMaxGrad = 0.0;
    for (uint i = 0u; i < tileSize; ++i) {
        wgMaxGrad = max(wgMaxGrad, sharedGrad[i][0]);
    }

    // Global reduction: only leader writes (subgroup or atomic)
    if (gl_GlobalInvocationID.x == 0u && gl_GlobalInvocationID.y == 0u) {
        // Atomic add for global var/ent/grad (normalize 0-1)
        atomicAdd(stats.variance, clamp(wgVar, 0.0, 1.0));
        atomicAdd(stats.entropy, clamp(wgEnt, 0.0, 4.0));  // Max ent=2 bits for 4 bins
        atomicAdd(stats.gradMag, clamp(wgMaxGrad, 0.0, 1.0));

        // Total rays = pixels (proxy)
        uvec2 imgSize = imageSize(prevOutput);
        stats.totalRays = imgSize.x * imgSize.y;
    }
}