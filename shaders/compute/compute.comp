#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

// ---------------------------------------------------------------------
//  Compute Workgroup
// ---------------------------------------------------------------------
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ---------------------------------------------------------------------
//  Bindings â€“ Matches VulkanRTX::DescriptorBindings
// ---------------------------------------------------------------------
layout(set = 0, binding = 1, rgba8) uniform image2D storageImage;     // RTX output
layout(set = 0, binding = 5, rgba8) uniform image2D denoiseImage;     // Denoised input
layout(set = 0, binding = 8, rgba8) uniform image2D gDepth;           // G-Buffer Depth
layout(set = 0, binding = 9, rgba8) uniform image2D gNormal;          // G-Buffer Normal

// ---------------------------------------------------------------------
//  Push Constants
// ---------------------------------------------------------------------
layout(push_constant) uniform PushConstants {
    vec2 resolution;
    uint frameIndex;
    uint enableDenoise;
    uint enableGBuffer;
    float exposure;
    float bloomThreshold;
    uint enableBloom;
    uint enableVignette;
} pc;

// ---------------------------------------------------------------------
//  Helper: PCG Random
// ---------------------------------------------------------------------
uint pcg(inout uint state) {
    uint prev = state;
    state = state * 747796405u + 2891336453u;
    uint word = ((prev >> ((prev >> 28u) + 4u)) ^ prev) * 277803737u;
    return (word >> 22u) ^ word;
}

float rand(inout uint seed) {
    return float(pcg(seed)) / 4294967295.0;
}

// ---------------------------------------------------------------------
//  Reinhard + Exposure
// ---------------------------------------------------------------------
vec3 toneMap(vec3 color, float exposure) {
    color *= exposure;
    return color / (color + vec3(1.0));
}

// ---------------------------------------------------------------------
//  Simple Bloom Extract (Threshold)
// ---------------------------------------------------------------------
vec3 extractBloom(vec3 color, float threshold) {
    float luma = dot(color, vec3(0.299, 0.587, 0.114));
    return max(color - threshold, 0.0) * (luma > threshold ? 1.0 : 0.0);
}

// ---------------------------------------------------------------------
//  Vignette
// ---------------------------------------------------------------------
float vignette(vec2 uv) {
    vec2 center = uv * 2.0 - 1.0;
    float dist = length(center);
    return smoothstep(1.0, 0.3, dist);
}

// ---------------------------------------------------------------------
//  Main
// ---------------------------------------------------------------------
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pc.resolution.x) || pixel.y >= int(pc.resolution.y)) return;

    vec2 uv = vec2(pixel) / pc.resolution;

    // Load RTX output
    vec4 rtxColor = imageLoad(storageImage, pixel);
    vec3 color = rtxColor.rgb;

    // Optional: blend with denoised result
    if (pc.enableDenoise != 0) {
        vec3 denoised = imageLoad(denoiseImage, pixel).rgb;
        color = mix(color, denoised, 0.9);
    }

    // Tone mapping with exposure
    color = toneMap(color, pc.exposure);

    // Bloom extract (optional)
    if (pc.enableBloom != 0) {
        vec3 bloom = extractBloom(color, pc.bloomThreshold);
        color += bloom * 0.8;
    }

    // Vignette
    if (pc.enableVignette != 0) {
        float v = vignette(uv);
        color *= v;
    }

    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));

    // Optional: add film grain
    uint seed = uint(pc.frameIndex * 73856093u + pixel.x * 19349663u + pixel.y * 83492791u);
    float grain = (rand(seed) - 0.5) * 0.03;
    color += grain;

    // Write final color
    imageStore(storageImage, pixel, vec4(color, rtxColor.a));
}