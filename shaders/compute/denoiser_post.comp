#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

// ---------------------------------------------------------------------
//  Compute Workgroup
// ---------------------------------------------------------------------
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// ---------------------------------------------------------------------
//  Bindings – Extended to Non-Conflicting (Post-RT Compute) – Matches VulkanRTX::DescriptorBindings (Set 0, Bindings 8-11)
// ---------------------------------------------------------------------
layout(set = 0, binding = 8, bgra8) readonly uniform image2D noisyImage;      // RTX output (fixed: bgra8 to match swapchain/ImageView VK_FORMAT_B8G8R8A8_UNORM – resolves format mismatch VUID)
layout(set = 0, binding = 9, bgra8) uniform image2D denoisedImage;           // Output (fixed: bgra8 for exact storage match)
layout(set = 0, binding = 10, r32f) readonly uniform image2D gDepth;         // Depth
layout(set = 0, binding = 11, rgba8) readonly uniform image2D gNormal;       // Normal (assumes RGBA8_UNORM; STORAGE_BIT required on creation)

// ---------------------------------------------------------------------
//  Push Constants (Shared w/ RT Pipeline)
// ---------------------------------------------------------------------
layout(push_constant) uniform PushConstants {
    vec2 resolution;
    uint frameIndex;
    uint enableDenoise;
    uint enableEdgePreserve;
    float sigmaColor;
    float sigmaSpatial;
    float sigmaNormal;
} pc;

// ---------------------------------------------------------------------
//  Helper: Gaussian Weight
// ---------------------------------------------------------------------
float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

// ---------------------------------------------------------------------
//  Main – Bilateral Denoise (Integrated Post-RT Dispatch)
// ---------------------------------------------------------------------
void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (pos.x >= int(pc.resolution.x) || pos.y >= int(pc.resolution.y)) return;

    vec3 centerColor = imageLoad(noisyImage, pos).bgr;  // FIXED: Swizzle BGRA→RGB (since bgra8 load returns vec4(B,G,R,A); extract .bgr for RGB)
    float centerDepth = imageLoad(gDepth, pos).r;
    vec3 centerNormal = imageLoad(gNormal, pos).rgb * 2.0 - 1.0;
    centerNormal = normalize(centerNormal);

    vec3 sum = vec3(0.0);
    float weightSum = 0.0;

    const int radius = 4;
    for (int y = -radius; y <= radius; ++y) {
        for (int x = -radius; x <= radius; ++x) {
            ivec2 samplePos = pos + ivec2(x, y);
            if (samplePos.x < 0 || samplePos.y < 0 || 
                samplePos.x >= int(pc.resolution.x) || samplePos.y >= int(pc.resolution.y)) 
                continue;

            vec4 sampleColorVec = imageLoad(noisyImage, samplePos);
            vec3 sampleColor = sampleColorVec.bgr;  // FIXED: Swizzle for BGRA
            float sampleDepth = imageLoad(gDepth, samplePos).r;
            vec3 sampleNormal = imageLoad(gNormal, samplePos).rgb * 2.0 - 1.0;
            sampleNormal = normalize(sampleNormal);

            // Spatial weight
            float dist = length(vec2(x, y));
            float wSpatial = gaussian(dist, pc.sigmaSpatial);

            // Color weight
            float colorDiff = length(centerColor - sampleColor);
            float wColor = gaussian(colorDiff, pc.sigmaColor);

            // Normal weight
            float normalDiff = max(0.0, dot(centerNormal, sampleNormal));
            float wNormal = gaussian(1.0 - normalDiff, pc.sigmaNormal);

            // Depth weight
            float depthDiff = abs(centerDepth - sampleDepth);
            float wDepth = gaussian(depthDiff, pc.sigmaSpatial * 0.1);

            float weight = wSpatial * wColor * wNormal * wDepth;
            sum += sampleColor * weight;
            weightSum += weight;
        }
    }

    vec3 denoised = weightSum > 0.0 ? sum / weightSum : centerColor;

    // Optional: passthrough if disabled
    if (pc.enableDenoise == 0) {
        denoised = centerColor;
    }

    // FIXED: Store as BGRA (swizzle RGB→BGR, alpha=1.0) to match format
    imageStore(denoisedImage, pos, vec4(denoised.bgr, 1.0));
}