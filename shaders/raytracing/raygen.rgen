#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require

#define MAX_FRAMES_IN_FLIGHT 3

// === BINDINGS ===
layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D rtOutput[MAX_FRAMES_IN_FLIGHT];
layout(set = 0, binding = 2, rgba32f) uniform image2D accumulation[MAX_FRAMES_IN_FLIGHT];

layout(set = 0, binding = 3, scalar) uniform FrameUBO {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 camPos;
    uint frame;
    float time;
    float jitterX;
    float jitterY;
} ubo;

layout(set = 0, binding = 6, rgba32f) uniform writeonly image2D nexusScore;

// === PUSH CONSTANT ===
layout(push_constant, std430) uniform PushConstants {
    uint frame;
} push;

void main()
{
    const uvec2 pixel = gl_LaunchIDEXT.xy;
    const vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
    vec2 ndc = uv * 2.0 - 1.0;

    vec4 origin    = ubo.viewInverse * vec4(0.0, 0.0, 0.0, 1.0);
    vec4 target    = ubo.projInverse * vec4(ndc, 1.0, 1.0);
    vec4 direction = ubo.viewInverse * vec4(normalize(target.xyz - origin.xyz), 0.0);

    vec3 radiance = vec3(0.0);

    rayQueryEXT query;
    rayQueryInitializeEXT(query, tlas, gl_RayFlagsOpaqueEXT, 0xFF,
                          origin.xyz, 0.001, direction.xyz, 10000.0);

    while (rayQueryProceedEXT(query)) {}

    if (rayQueryGetIntersectionTypeEXT(query, true) != gl_RayQueryCommittedIntersectionNoneEXT)
    {
        // CORRECT: barycentrics is vec2 â†’ compute third component manually
        vec2 bary2 = rayQueryGetIntersectionBarycentricsEXT(query, true);
        float w = 1.0 - bary2.x - bary2.y;
        vec3 bary = vec3(w, bary2.x, bary2.y);

        // Fake normal from barycentrics (good enough for first light)
        vec3 normal = normalize(bary);
        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
        float NdotL = max(dot(normal, lightDir), 0.0);

        radiance = vec3(0.93, 0.25, 0.80) * (0.15 + 0.85 * NdotL); // ULTRA PINK
    }
    else
    {
        // Eternal pink sky
        radiance = mix(vec3(0.96, 0.38, 0.88), vec3(0.99, 0.78, 0.96), pow(uv.y, 0.6));
    }

    // Temporal accumulation
    vec3 prev = imageLoad(accumulation[push.frame % MAX_FRAMES_IN_FLIGHT], ivec2(pixel)).rgb;
    vec3 color = mix(prev, radiance, 1.0 / float(push.frame + 1));

    imageStore(rtOutput[push.frame % MAX_FRAMES_IN_FLIGHT], ivec2(pixel), vec4(color, 1.0));
    imageStore(nexusScore, ivec2(0,0), vec4(color, 1.0));
}