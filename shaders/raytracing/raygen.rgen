#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "VulkanCommon.hpp"

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D rtOutput;
layout(set = 0, binding = 2) uniform UniformBufferObject { ... } ubo;
layout(set = 0, binding = 3) buffer MaterialBuffer { MaterialData m[]; } materials;
layout(set = 0, binding = 4) buffer DimensionBuffer { float d[]; } dimensions;
layout(set = 0, binding = 5) uniform sampler2D envMap;
layout(set = 0, binding = 6, rgba32f) uniform image2D accumImg;

layout(location = 0) rayPayloadEXT vec3 hitValue;
layout(location = 1) rayPayloadEXT bool shadowed;
layout(location = 2) rayPayloadEXT vec3 radiance;

layout(push_constant) uniform PushConstants {
    vec4 clearColor;
    vec3 cameraPosition;
    float _pad0;
    vec3 lightDirection;
    float lightIntensity;
    uint samplesPerPixel;
    uint maxDepth;
    uint maxBounces;
    float russianRoulette;
    vec2 resolution;
    uint showEnvMapOnly;
} pc;

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 uv = pixelCenter / pc.resolution;
    const vec2 inUV = (uv * 2.0 - 1.0);

    vec3 origin = pc.cameraPosition;
    vec3 direction = normalize(vec3(inUV, -1.0));

    vec3 color = vec3(0.0);
    float alpha = 1.0;

    if (pc.showEnvMapOnly == 1) {
        color = texture(envMap, uv).rgb;
    } else {
        radiance = vec3(0.0);
        traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin, 0.001, direction, 10000.0, 2);
        color = radiance;
    }

    vec4 prev = imageLoad(accumImg, ivec2(gl_LaunchIDEXT.xy));
    vec4 accum = mix(prev, vec4(color, 1.0), alpha);

    imageStore(rtOutput, ivec2(gl_LaunchIDEXT.xy), accum);
    imageStore(accumImg, ivec2(gl_LaunchIDEXT.xy), accum);
}