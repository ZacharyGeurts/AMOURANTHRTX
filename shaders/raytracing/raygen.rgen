// shaders/raytracing/raygen.rgen
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_ARB_gpu_shader_int64 : require

#include "../StoneKey.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;

layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D rtOutput;
layout(set = 0, binding = 2, rgba32f) uniform readonly image2D accumulation;

// BINDING 3 — 100% SCALAR + 16-BYTE ALIGNED — NO ARRAYS OF 3
layout(set = 0, binding = 3, scalar) uniform FrameUBO {
    mat4  viewInverse;
    mat4  projInverse;
    vec4  camPos;
    uint  frame;
    float time;
    float jitterX;
    float jitterY;
    // EXPLICIT PADDING — 4 uints = 16 bytes → PERFECT ALIGNMENT
    uint  _pad0;
    uint  _pad1;
    uint  _pad2;
    uint  _pad3;
} ubo;

layout(set = 0, binding = 6, rgba32f) uniform writeonly image2D nexusScore;

layout(push_constant, std430) uniform Push {
    uint frame;
} push;

layout(location = 0) rayPayloadEXT vec3 hitValue;

void main()
{
    const uvec2 pixel = gl_LaunchIDEXT.xy;
    const vec2 uv = (vec2(pixel) + vec2(0.5f)) / vec2(gl_LaunchSizeEXT.xy);
    vec2 ndc = uv * 2.0f - 1.0f;
    ndc += vec2(ubo.jitterX, ubo.jitterY);

    vec4 origin = ubo.viewInverse * vec4(0.0f, 0.0f, 0.0f, 1.0f);
    vec4 target = ubo.projInverse * vec4(ndc, 1.0f, 1.0f);
    vec4 dir    = ubo.viewInverse * vec4(normalize(target.xyz - origin.xyz), 0.0f);

    hitValue = vec3(0.0f);

    traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 0, 0,
                origin.xyz, 0.001f, dir.xyz, 10000.0f, 0);

    vec3 color = hitValue;
    if (all(equal(color, vec3(0.0f)))) {
        color = mix(vec3(0.96f, 0.38f, 0.88f), vec3(0.99f, 0.78f, 0.96f), pow(uv.y, 0.6f));
    }

    vec3 prev = imageLoad(accumulation, ivec2(pixel)).rgb;
    color = mix(prev, color, 1.0f / float(push.frame + 1u));

    imageStore(rtOutput, ivec2(pixel), vec4(color, 1.0f));

    if (pixel.x == 0 && pixel.y == 0) {
        imageStore(nexusScore, ivec2(0,0), vec4(color, 1.0f));
    }
}