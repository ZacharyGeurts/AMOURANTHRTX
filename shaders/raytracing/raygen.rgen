// File: shaders/raytracing/raygen.rgen
// Vulkan 1.4 / SPIR-V 1.6 — this compiles 100% with glslc (no overload error)

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

#define MAX_FRAMES_IN_FLIGHT 3

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1, rgba32f) uniform writeonly image2D rtOutput[MAX_FRAMES_IN_FLIGHT];
layout(set = 0, binding = 2, rgba32f) uniform image2D accumulation[MAX_FRAMES_IN_FLIGHT];

layout(set = 0, binding = 3, scalar) uniform FrameUBO {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 camPos;
    uint frame;
    float time;
    float jitterX;
    float jitterY;
} ubo;

layout(set = 0, binding = 6, rgba32f) uniform writeonly image2D nexusScore;

layout(push_constant, std430) uniform PushConstants {
    uint frame;
} push;

// PAYLOAD — location 0
layout(location = 0) rayPayloadEXT vec3 hitValue;

void main()
{
    const uvec2 pixel = gl_LaunchIDEXT.xy;
    const vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
    vec2 ndc = uv * 2.0 - 1.0;

    vec4 origin = ubo.viewInverse * vec4(0.0, 0.0, 0.0, 1.0);
    vec4 target = ubo.projInverse * vec4(ndc, 1.0, 1.0);
    vec4 dirTmp = ubo.viewInverse * vec4(normalize(target.xyz - origin.xyz), 0.0);

    hitValue = vec3(0.0);

    // 11-PARAMETER CALL — this is the ONLY signature that exists
    traceRayEXT(
        tlas,                 // accelerationStructureEXT
        0,                    // rayFlags (0 = no special flags = opaque behavior)
        0xFF,                 // cullMask
        0,                    // sbtRecordOffset
        0,                    // sbtRecordStride
        0,                    // missIndex
        origin.xyz,           // origin
        0.001,                // tmin
        dirTmp.xyz,           // direction
        10000.0,              // tmax
        0                     // ← PAYLOAD LOCATION (int) — THIS WAS MISSING
    );

    vec3 radiance = hitValue;
    if (all(equal(radiance, vec3(0.0))))
        radiance = mix(vec3(0.96, 0.38, 0.88), vec3(0.99, 0.78, 0.96), pow(uv.y, 0.6));

    vec3 prev = imageLoad(accumulation[push.frame % MAX_FRAMES_IN_FLIGHT], ivec2(pixel)).rgb;
    vec3 color = mix(prev, radiance, 1.0 / float(push.frame + 1));

    imageStore(rtOutput[push.frame % MAX_FRAMES_IN_FLIGHT], ivec2(pixel), vec4(color, 1.0));
    imageStore(nexusScore, ivec2(0,0), vec4(color, 1.0));
}