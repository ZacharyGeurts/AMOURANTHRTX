#version 460
#extension GL_EXT_ray_tracing : require

layout(location = 0) rayPayloadEXT vec3 payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1, rgba32f) uniform image2D outputImage;
layout(set = 0, binding = 2) uniform UniformBuffer {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 camPos;
    float time;
    uint frame;
} ubo;
layout(set = 0, binding = 5) uniform sampler2D envMap;

layout(push_constant) uniform PushConstants {
    uint renderMode;
    uint showEnvMapOnly;
} pc;

vec2 hash2(vec2 p) {
    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),
                         dot(p, vec2(269.5, 183.3)))) * 43758.5453);
}

void main()
{
    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + 0.5) / vec2(gl_LaunchSizeEXT.xy);
    uv.y = 1.0 - uv.y;

    const uint spp = 4;
    vec3 accum = vec3(0.0);

    for (uint i = 0; i < spp; ++i)
    {
        vec2 jUV = uv + (hash2(uv + float(ubo.frame) + float(i)) - 0.5) /
                       vec2(gl_LaunchSizeEXT.xy);

        vec3 origin = ubo.camPos.xyz;
        vec2 ndc = jUV * 2.0 - 1.0;
        vec4 target = ubo.projInverse * vec4(ndc, -1.0, 1.0);
        target /= target.w;
        vec3 dir = normalize((ubo.viewInverse * vec4(target.xyz - ubo.camPos.xyz, 0.0)).xyz);

        payload = vec3(0.0);  // ← CRITICAL: INITIALIZE

        traceRayEXT(
            tlas,
            gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
            0xFF, 0, 1, 0,  // ← FIXED: sbtRecordStride = 1, missIndex = 0
            origin, 0.001, dir, 1000.0, 0
        );

        accum += payload;
    }

    accum /= float(spp);

    if (pc.showEnvMapOnly == 1)
    {
        vec3 dir = normalize((ubo.viewInverse * vec4(uv * 2.0 - 1.0, -1.0, 1.0)).xyz);
        float theta = atan(dir.z, dir.x);
        float phi   = acos(dir.y);
        vec2 envUV  = vec2(theta / (2.0 * 3.14159265) + 0.5, phi / 3.14159265);
        accum = texture(envMap, envUV).rgb;
    }

    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(accum, 1.0));
}