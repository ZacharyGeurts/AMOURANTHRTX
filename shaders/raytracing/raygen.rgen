// assets/shaders/raytracing/raygen.rgen
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

layout(location = 0) rayPayloadEXT vec3 hitValue;
layout(location = 1) rayPayloadEXT float visibility;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, rgba8) uniform image2D outputImage;
layout(binding = 2) uniform CameraUBO {
    mat4 view;
    mat4 proj;
    int mode;
} camera;

layout(binding = 5, rgba8) uniform image2D denoiseImage;
layout(binding = 6) uniform sampler2D envMap;

layout(push_constant) uniform PushConstants {
    vec4 clearColor;
    vec3 cameraPosition;
    vec3 lightDirection;
    vec3 lightColor;
    float lightIntensity;
    uint samplesPerPixel;
    uint maxDepth;
    uint maxBounces;
    float russianRoulette;
} push;

void main() {
    ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    vec2 pixelCenter = (vec2(pixel) + vec2(0.5)) / vec2(gl_LaunchSizeEXT.xy);
    vec2 ndc = 2.0 * pixelCenter - 1.0;
    ndc.y = -ndc.y;

    mat4 invVP = inverse(camera.proj * camera.view);
    vec4 target = invVP * vec4(ndc, -1.0, 1.0);
    vec3 targetPos = target.xyz / target.w;
    vec3 rayOrigin = push.cameraPosition;
    vec3 rayDir = normalize(targetPos - rayOrigin);

    hitValue = push.clearColor.rgb;
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT | gl_RayFlagsCullBackFacingTrianglesEXT, 0xFF,
                0, 1, 0,
                rayOrigin, 0.001, rayDir, 1000.0, 0);

    vec4 accum = imageLoad(denoiseImage, pixel);
    vec4 newSample = vec4(hitValue, 1.0);
    imageStore(outputImage, pixel, mix(accum, newSample, 1.0 / float(push.samplesPerPixel + 1)));
}