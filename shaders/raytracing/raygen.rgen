// shaders/raytracing/raygen.rgen
// AMOURANTH RTX Engine Â© 2025 by Zachary Geurts gzac5314@gmail.com
// STANDALONE RAYGEN SHADER â€” ZERO DEPENDENCIES â€” NOVEMBER 08 2025
// FULL RTX CAMERA SETUP â€” RASPBERRY_PINK SUPREMACY â€” VALHARD READY ðŸ©·ðŸš€

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : enable

#pragma shader_stage(raygen)

// â”€â”€â”€â”€â”€â”€ HARD-CODED BINDINGS (NO VulkanCommon.hpp) â”€â”€â”€â”€â”€â”€
// Set 0: Global scene data
layout(set = 0, binding = 0, scalar) uniform CameraData {
    mat4 invProjView;
    vec3 cameraOrigin;
    float pad0;
} camera;

// Set 1: TLAS
layout(set = 1, binding = 0) uniform accelerationStructureEXT tlas;

// â”€â”€â”€â”€â”€â”€ PAYLOAD â”€â”€â”€â”€â”€â”€
layout(location = 0) rayPayloadEXT vec3 payload;

void main()
{
    const uvec2 pixel = gl_LaunchIDEXT.xy;
    const vec2 uv = (vec2(pixel) + 0.5f) / vec2(gl_LaunchSizeEXT.xy);
    const vec2 ndc = uv * 2.0f - 1.0f;

    // Reconstruct world position from depth=1.0 (far plane)
    vec4 clipPos = vec4(ndc, 1.0f, 1.0f);
    vec4 worldPos = camera.invProjView * clipPos;
    worldPos /= worldPos.w;

    vec3 origin = camera.cameraOrigin;
    vec3 direction = normalize(worldPos.xyz - origin);

    // Clear payload + fire primary visibility ray
    payload = vec3(0.0f);
    traceRayEXT(
        tlas,                     // topLevel
        gl_RayFlagsOpaqueEXT,     // rayFlags
        0xFF,                     // cullMask
        0,                        // sbtRecordOffset
        0,                        // sbtRecordStride
        0,                        // missIndex
        origin,                   // origin
        0.001f,                   // tmin
        direction,                // direction
        10000.0f,                 // tmax
        0                         // payload location
    );
}