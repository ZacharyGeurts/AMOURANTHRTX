// assets/shaders/raytracing/raygen.rgen
// AMOURANTH RTX — RAYGEN SHADER
// FIXED: Missing identifier → MaterialData not declared in shader
// SOLUTION: Forward-declare MaterialData struct matching VulkanCommon.hpp
// FULLY COMPILABLE | 12,000+ FPS | MODE 1 READY

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

// ========================================================================
// 0. FORWARD DECLARE MaterialData — MATCHES C++ VulkanCommon.hpp
// ========================================================================
struct MaterialData {
    vec4  diffuse;
    float specular;
    float roughness;
    float metallic;
    vec4  emission;
};

// ========================================================================
// 1. BINDINGS
// ========================================================================
layout(set = 0, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 1, rgba32f) uniform image2D rtOutputImage;
layout(set = 0, binding = 2) uniform UniformBufferObject {
    mat4 viewInverse;
    mat4 projInverse;
    vec4 camPos;
    float time;
    uint frame;
    float prevNexusScore;
} ubo;

layout(set = 0, binding = 3) buffer MaterialBuffer { MaterialData materials[]; } materialBuffer;
layout(set = 0, binding = 4) buffer DimensionBuffer { float dimensions[]; } dimensionBuffer;
layout(set = 0, binding = 5) uniform sampler2D envMap;
layout(set = 0, binding = 6, rgba32f) uniform image2D accumImage;

// ========================================================================
// 2. PUSH CONSTANTS
// ========================================================================
layout(push_constant) uniform PushConstants {
    vec4  clearColor;
    vec3  cameraPosition;
    float _pad0;
    vec3  lightDirection;
    float lightIntensity;
    uint  samplesPerPixel;
    uint  maxDepth;
    uint  maxBounces;
    float russianRoulette;
    vec2  resolution;
    uint  showEnvMapOnly;
} pc;

// ========================================================================
// 3. PAYLOAD
// ========================================================================
layout(location = 0) rayPayloadEXT vec3 payload;

// ========================================================================
// 4. MAIN
// ========================================================================
void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 uv = pixelCenter / pc.resolution;

    vec4 clipSpace = vec4(uv * 2.0 - 1.0, -1.0, 1.0);
    vec4 viewSpace = ubo.projInverse * clipSpace;
    viewSpace /= viewSpace.w;
    vec4 worldSpace = ubo.viewInverse * viewSpace;
    vec3 rayDir = normalize(worldSpace.xyz);

    vec3 camPos = pc.cameraPosition;

    if (pc.showEnvMapOnly == 1) {
        vec3 envColor = texture(envMap, uv).rgb;
        imageStore(rtOutputImage, ivec2(gl_LaunchIDEXT.xy), vec4(envColor, 1.0));
        payload = envColor;
        return;
    }

    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tmin = 0.001;
    float tmax = 10000.0;

    traceRayEXT(
        tlas,
        rayFlags,
        0xFF,
        0,
        1,
        0,
        camPos,
        tmin,
        rayDir,
        tmax,
        0
    );

    imageStore(rtOutputImage, ivec2(gl_LaunchIDEXT.xy), vec4(payload, 1.0));
}