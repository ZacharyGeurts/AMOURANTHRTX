#version 460
#extension GL_EXT_shader_image_load_formatted : require
#extension GL_KHR_shader_subgroup_basic      : require

// ---------------------------------------------------------------------------
//  Layout – matches VulkanRenderer::updateNexusDescriptors()
// ---------------------------------------------------------------------------
layout(set = 0, binding = 0, rgba32f) readonly  uniform image2D  prevAccum;   // previous accumulation
layout(set = 0, binding = 1, rgba32f) readonly  uniform image2D  currOutput;  // current RT output
layout(set = 0, binding = 2)          uniform  BufferStats {
    uint   hitCount;
    uint   totalRays;
    float  variance;
    float  entropy;
    float  gradMag;
    float  pad[3];
} stats;
layout(set = 0, binding = 3, r32f)    writeonly uniform image2D  scoreOut;   // 1x1 score image

// ---------------------------------------------------------------------------
//  Push-constant block (weights + thresholds + FPS mode)
// ---------------------------------------------------------------------------
layout(push_constant) uniform PushConsts {
    float w_var;      // variance weight
    float w_ent;      // entropy weight
    float w_hit;      // hit-rate weight
    float w_grad;     // gradient weight
    float w_res;      // resonance-threshold weight
    uint  fpsTarget;  // 60 or 120
    float pad[2];
} pc;

// ---------------------------------------------------------------------------
//  Helper: simple reduction over a 16x16 tile
// ---------------------------------------------------------------------------
void main()
{
    // One invocation per pixel – we only need a single value in the 1x1 score image
    if (gl_GlobalInvocationID.x != 0 || gl_GlobalInvocationID.y != 0)
        return;

    // ---------------------------------------------------------------
    // 1. Hit-rate (0-1)
    // ---------------------------------------------------------------
    float hitRate = (stats.totalRays > 0)
                  ? float(stats.hitCount) / float(stats.totalRays)
                  : 0.0;

    // ---------------------------------------------------------------
    // 2. Normalised variance / entropy / gradient (already in [0,1] range)
    // ---------------------------------------------------------------
    float var   = stats.variance;
    float ent   = stats.entropy;
    float grad  = stats.gradMag;

    // ---------------------------------------------------------------
    // 3. FPS-AWARE WEIGHT ADAPTATION
    // ---------------------------------------------------------------
    float effective_w_var  = pc.w_var;
    float effective_w_ent  = pc.w_ent;
    float effective_w_hit  = pc.w_hit;
    float effective_w_grad = pc.w_grad;

    if (pc.fpsTarget == 120) {
        // 120 FPS: Prioritize stability & hit-rate → reduce variance/entropy noise
        effective_w_var  *= 0.7;  // Less sensitive to noise
        effective_w_ent  *= 0.7;
        effective_w_hit  *= 1.3;  // More emphasis on ray efficiency
        effective_w_grad *= 1.1;  // Slightly more edge-aware
    } else {
        // 60 FPS: Allow more aggressive denoising → trust variance/entropy
        effective_w_var  *= 1.2;
        effective_w_ent  *= 1.2;
        effective_w_hit  *= 0.9;
        effective_w_grad *= 0.9;
    }

    // ---------------------------------------------------------------
    // 4. Combine with adapted weights
    // ---------------------------------------------------------------
    float rawScore = effective_w_var  * var
                   + effective_w_ent  * ent
                   + effective_w_hit  * hitRate
                   + effective_w_grad * grad;

    // ---------------------------------------------------------------
    // 5. Resonance threshold (optional — can be used in host code)
    // ---------------------------------------------------------------
    float resonance = pc.w_res;  // Pass-through for host-side logic

    // ---------------------------------------------------------------
    // 6. Clamp & write to 1x1 score image
    // ---------------------------------------------------------------
    float finalScore = clamp(rawScore, 0.0, 1.0);
    imageStore(scoreOut, ivec2(0,0), vec4(finalScore, resonance, float(pc.fpsTarget), 0.0));
}